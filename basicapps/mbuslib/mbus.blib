' This script is an example of the EMDO101 energy manager
' Please visit us at www.swissembedded.com
' Copyright (c) 2016-2017 swissEmbedded GmbH, All rights reserved.
' @DESCRIPTION EMDO m-bus master slave library
' @VERSION 1.0
' Protocols are freely available from http://www.m-bus.com/

' (W)MBus Transmit single char
' itf$  Interface with string. Example "WMbus" or "Mbus"
' return   0 = ok, negative value = error
FUNCTION msTxSingleChar(itf$)
 IF itf$="WMbus" THEN
  WMbusWrite(&HE5)
 ELSEIF itf$="Mbus" THEN
  MbusWrite(&HE5)
 ENDIF
 msTxSingleChar=0
END FUNCTION

' (W)MBus Receive single char
' itf$  Interface with string. Example "WMbus" or "WMbus"
' return   0 = ok, negative value = error
FUNCTION msRxSingleChar(itf$)
 LOCAL rsp$, sc$
 sc$=chr$(&HE5)	
 IF itf$="WMbus" THEN
  rsp$=WMbusReadLn$(2000,sc$)
 ELSEIF itf$="Mbus" THEN
  rsp$=MbusReadLn$(2000,sc$)
 ENDIF
 IF rsp$=sc$ THEN
  msRxSingleChar=0
 ELSE
  msRxSingleChar=-1
 END IF
END FUNCTION 

' (W)MBus transimt Short Frame
' itf$  Interface with string. Example "WMbus" or "Mbus"
' C%  Control field, function field
' A%  Address field
' return   0 = ok, negative value = error
FUCTION msTxShortFrame(itf$,C%,A%)
 ' Address check first
 IF NOT ((A%>=1 AND A%<=250) OR A%=254 OR A%=255) THEN
  ' Address is out of the range
  msTxShortFrame=-10
  EXIT FUNCTION 
 ENDIF
 
 ' frame fields: start(10h),C, A, checksum, stop(16h)
 LOCAL checksum%=mgCalChecksum("shortFrame",C%,A%,0,"")
 ' transmit frame
 IF itf$="WMbus" THEN
  WMbusWrite(&H10, C%, A%, checksum%,&H16)  
 ELSEIF itf$="Mbus" THEN
  MbusWrite(&H10, C%, A%, checksum%,&H16)
 ENDIF 
 msTxShortFrame=0
END FUNCTION


' (W)MBus recieve Short Frame
' itf$  Interface with string. Example "Mbus" or "WMbus"
' return   0 = ok, negative value = error
FUNCTION mgRxShortFrame (itf$)
 LOCAL scStart$, startByte$, C%, A%, checksumRecieved%, checksumCalculated%, scStop$, stopByte$
 scStart$=chr$(&H10)
 scStop$=chr$(&H16)
 
 IF itf$="WMbus" THEN
  startByte$=WMbusReadLn$(2000,scStart$)
 ELSEIF itf$="Mbus" THEN
  startByte$=MbusReadLn$(2000,scStart$)
 END IF
 
 IF NOT (startByte$=scStart$) THEN
  ' recieved byte is not the start byte of the short frame
  msRxShortFrame=-11
  EXIT FUNCTION
 END IF
 
 IF itf$="WMbus" THEN
  C%=WMbusRead()
  A%=WMbusRead()
  checksumRecieved%=WMbusRead()
  stopByte$=WMbusRead()
 ELSEIF itf$="Mbus" THEN
  C%=MbusRead()
  A%=MbusRead()
  checksumRecieved%=MbusRead()
  stopByte$=MbusRead()
 END IF
 
 ' check the validity of the frame
 checksumCalculated%=mgCalChecksum("ShortFrame",C%,A%,0,"")
 IF NOT (checksumCalculated%=checksumRecieved% AND stopByte$=scStop$)
  'the frame is not valid
  mgRxShortFrame=-12
  EXIT FUNCTION
 END IF

 mgRxShortFrame=0
END FUNCTION


' (W)MBus transmit Control Frame
' itf$  Interface with string.Example "WMbus" or "WMbus"
' L%   L Field
' C%  Control field, function field
' A%  Address field
' CI% Control information field
' return   0 = ok, negative value = error
FUNCTION msTxControlFrame(itf$,C%,A%,CI%)
 ' Check address first
 IF NOT ((A%>=1 AND A%<=250) OR A%=254 OR A%=255) THEN
  ' Address is out of the range
  msTxShortFrame=-13
  EXIT FUNCTION 
 ENDIF
 
 ' frame fields: firstStart(68h), firstLength(3), secondLength(3), secondStart(68h), C, A, CI, checksum, stop(16h)
 LOCAL checksum%=mgCalChecksum("controlFrame",C%,A%,CI%,"")
 LOCAL firstLength%=3, secondLength%=3
 ' transmit frame
 IF itf$="WMbus" THEN
  WMbusWrite(&H68,firstLength%,secondLength%,C%,A%,CI%,checksum%,&H16)  
 ELSEIF itf$="Mbus" THEN
  MbusWrite(&H68,firstLength%,secondLength%,C%,A%,CI%,checksum%,&H16)
 ENDIF 
 msTxControlFrame=0
END FUNCTION


' (W)MBus recieve Control Frame
' itf$  Interface with string.Example "WMbus" or "WMbus"
' L%   L Field
' C%  Control field, function field
' A%  Address field
' CI% Control information field
' return   0 = ok, negative value = error
FUNCTION msRxControlFrame(itf$)
 LOCAL scStart$, firstStartByte$, scLength$, firstLength%, secondLength%, secondStartByte$, C%, A%, checksumRecieved%, checksumCalculated%, scStop$, stopByte$
 scStart$=chr$(&H68)
 scStop$=chr$(&H16)
 
 IF itf$="WMbus" THEN
  firstStartByte$=WMbusReadLn$(2000,scStart$)
 ELSEIF itf$="Mbus" THEN
  firstStartByte$=MbusReadLn$(2000,scStart$)
 END IF
 
 IF NOT (startByte$=scStart$) THEN
  ' recieved byte is not the start byte of the control frame
  msRxControlFrame=-14
  EXIT FUNCTION
 END IF
 
 IF itf$="WMbus" THEN
  firstLength%=WMbusRead()
  secondLength%=WMbusRead()
 ELSEIF itf$="Mbus" THEN
  firstLength%=MbusRead()
  secondLength%=MbusRead()
 END IF
 
 IF NOT (firstLength%=3 AND secondLength%=3) THEN
  ' The first and second length are not equal to 3
  msRxControlFrame=-15
  EXIT FUNCTION
 END IF
 
 IF NOT (startByte$=scStart$) THEN
  ' recieved byte is not the start byte of the control frame
  msRxControlFrame=-14
  EXIT FUNCTION
 END IF
 
 IF itf$="WMbus" THEN
  C%=WMbusRead()
  A%=WMbusRead()
  checksumRecieved%=WMbusRead()
  stopByte$=WMbusRead()
 ELSEIF itf$="Mbus" THEN
  C%=MbusRead()
  A%=MbusRead()
  checksumRecieved%=MbusRead()
  stopByte$=MbusRead()
 END IF
 
 ' check the validity of the frame
 checksumCalculated%=mgCalChecksum("ShortFrame",C%,A%,0,"")
 IF NOT (checksumCalculated%=checksumRecieved% AND stopByte$=scStop$)
  'the frame is not valid
  mgRxShortFrame=-12
  EXIT FUNCTION
 END IF

 mgRxShortFrame=0
END FUNCTION


' (W)MBus receive Long Frame
' itf$  Interface with string.Example "WMbus" or "WMbus"
' L%   L Field
' C%  Control field, function field
' A%  Address field
' CI% Control information field
' Usr$ User Data
' return   0 = ok, negative value = error
FUNCTION msRxLongFrame(itf$,L%,C%,A%,CI%,Usr$)
 LOCAL err%
 msRxLongFrame=err%
END FUNCTION


' (W)MBus calculate frame checksum
' frameType$ the type of the frame 
' "shortFrame" (requires C% and A%)
' "controlFrame" (requires C% and A%, CI%)
' "longFrame" (requires C% and A%, CI% and userData$)
' C%  Control field, function field
' A%  Address field
' CI% Control information field
' Usr$ User Data
' return calculated checksum or -1 on error
FUNCTION msCalChecksum (frameType$,C%,A%,CI%,Usr$)
 LOCAL checksum%, i
 'The checksum value depends on the frame type
 IF frameType$="shortFrame" THEN
  checksum%=C%
  checksum%+=A%
 
 ELSE IF frameType$="controlFrame" THEN
  checksum%=C%
  checksum%+=A%
  checksum%+=CI%
 
 ELSE IF frameType$="longFrame" THEN
  checksum%=C%
  checksum%+=A%
  checksum%+=CI%
  
  For i = 1 to Len(Usr$)
   checksum%+=asc(mid$(Usr$,i,1))
  End i
 ELSE
  ' the packet type is unknown
  msCalChecksum=-1
  EXIT FUNCTION
 ENDIF
 msCalChecksum=checksum%
END FUNCTION
