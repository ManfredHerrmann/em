' This script is an example of the EMDO101 energy manager
' Please visit us at www.swissembedded.com
' Copyright (c) 2015-2016 swissEmbedded GmbH, All rights reserved.
' EMDO planning library, scheduling loads

' Some examples on usage 
' LIBRARY LOAD "planning"
'start:
' DISPATCH 1000
'goto start
 
'@lib_init
FUNCTION __planning_init()
 pbSize%=10
 pbMeterC$=pbMC"
 dim pbSch$(pbSize%)
 
 pbCronDesc%=CrontabAdd("* * * * *")
 IF pbCronDesc% < 0 THEN ERROR "Failed to add CRON entry"
 ELSE ON CRON pbCronDesc% pgCron
 
 pbTimerDesc%=SetTimer(10000)
 IF pbTimerDesc% < 0 THEN ERROR "Failed to add Timer entry"
 ELSE ON TIMER pbTimerDesc% pgTimer
END FUNCTION
 
'@lib_destroy
FUNCTION __planning_destroy()
 LOCAL sc%
 'sc%=CrontabRemove(pbCronDesc%)
END FUNCTION

' Load planning recalculate every minute (cron based)
' Cron handler called every minute
' id% cron identifier
' elapsed% time in ms elapsed since last schedule
' return -1 on error
' Callbacks:
' pbMC(pE,pI,pP,pS)
' pE exported energy to grid
' pI imported energy from grid
' pP produced energy by generator
' pS stored energy in battery
FUNCTION pbCron(id%,elapsed%)  
 LOCAL p%,it%,nm$,prio%,lpc$,ltc$,st$
 ' Read the power of the grid
 n%=CALL(pbMeterC$,pE,pI,pP,pS)
 IF n% < 0 THEN
  pbCron=-1
  print pbMeterC$ " can't be called!"
  EXIT FUNCTION
 ENDIF
 ' Planning of the loads
 ' IF we export go through list from priority 1 to 10
 IF pE > 0.0 THEN
  FOR p%=1 TO pbSize%
   FOR it%= 1 TO pbSize%
    IF pbGetLoad(it%,prio%,nm$,lpc$,ltc$)=p% THEN
	 ' Call the load in priorized order to increase load
	 n%=CALL(lpc$,id%,prio%,nm$,ltc$,pE,pI,pP,pS)
    ENDIF
   NEXT it%
  NEXT p%
 ELSE IF pI > 0.0 THEN
  FOR p%=pbSize% TO 1 STEP -1
   FOR it%= 1 TO pbSize%
    IF pbGetLoad(it%,prio%,nm$,lpc$,ltc$)=p% THEN
	 ' Call the load in priorized order to increase load
	 n%=CALL(lpc$,id%,prio%,nm$,ltc$,pE,pI,pP,pS)
    ENDIF
   NEXT it%
  NEXT p%
 ENDIF
 pbCron=0
END FUNCTION

' Get a load entry from the list
' id%  id of the load
' nm$  name of the load
' lpc$ load profile callback
' ltc$ load trigger callback
' return priority or -1 on error
FUNCTION pbGetLoad(id%, prio%, nm$, lpc$,ltc$)
 LOCAL st$
 pbGetLoad=-1
 st$=pbSch$(id%)
 IF len(st$) > 0 THEN
  prio%=val(split$(1,st$,";"))
  nm$=split$(2,st$,";")
  lpc$=split$(3,st$,";")
  ltc$=split$(4,st$,";")
  pbGetLoad=prio%
 ENDIF
END FUNCTION

' Add load
' id%  id of the load
' nm$  name of the load
' lpc$ load profile callback
' ltc$ load trigger callback
' return -1 on error, id% of added load
FUNCTION pbAdd(id%, prio%, nm$, lpc$, ltc$)
 LOCAL st$
 pbAdd=-1
 IF len(pbSch$(id%)) > 0 THEN
  ' Id already exists
  pbAdd=-1
  EXIT FUNCTION
 ENDIF
 st$=str$(prio%)+";"+nm$+";"+lpc$+";"+ltc$
 pbSch$(id%)=st$
 pbAdd=is%
END FUNCTION

' Remove load from planning
' id% id of the load to be removed
' return -1 on error or id% that has been removed
FUNCTION pbRemove(id%)
 pbRemove=-1
 IF len(pbSch$(id%)) > 0 THEN
  pbSch$(id%)=""
  pbRemove=id%
 ENDIF
END FUNCTION

' Load planning every 10 seconds (timer based)
' Timer handler called every minute
' id% cron identifier
' elapsed% time in ms elapsed since last schedule
FUNCTION pbTimer(id%,elapsed%)  
 PRINT "cron1 id=" id% " el=" elapsed% " date=" Date$()
 pbTimer=0
END FUNCTION

' Load planning adaptive learning of the load profile (recording)
' The data is stored binary (4 bytes per float)
' fn% filenumber to use
' nm$ name of the load
' rtm% run time of the device (relative time since start)
' itv% recording interval e.g. every 60 for every minute
' vl  current value
' vlt tolerance of the value, if value within tolerance, don't update flash(prevent flash wear out)
' wt  weight of the new value (0=don't learn at all..1=take new value, foget all old values)
' return -1 on error
FUNCTION pbRecord(fn%,nm$,rtm%,itv%,vl,vlt,wt)
local vlo, vln
' load the value
 ' Check if wt is in interval [0.0 1.0]
 IF wt < 0.0 or wt > 1.0 THEN
  pbRecord=-1
  EXIT FUNCTION
 ENDIF
 vln=vlo*(1.0-wt)+vl*wt
 ' Check if update is needed
 IF abs(vln-vlo) < vlt then
  pbRecord=0
  EXIT FUNCTION
 ENDIF
END FUNCTION

' Load planning adaptive learning of the load profile (retrieve)
' The data is stored binary (4 bytes per float)
' fn% filenumber to use
' nm$ name of the load
' rtm% run time of the device (relative time since start)
' itv% recording interval e.g. every 60 for every minute
' vl value at given time
' return -1 on error
FUNCTION pbRetrieve(fn%,nm$,rtm%,itv%, vl)
 LOCAL ps%,ln%
 pbRetrieve=-1
 IF rtm% < 0 THEN
  pbRetrieve=-1
  EXIT FUNCTION
 ENDIF
 ps%=(rtm%/itv%*4+1)
 open "dev_"+nm$ for input as # fn%
 ' check if this is past the end
 ln%=lof # fn%
 IF ln% >= (ps%+4) THEN
  seek # fn%, ps%
  pbRetrieve=ps%
 ENDIF
 close # fn%
END FUNCTION


